# -*- coding: utf-8 -*-
"""
/***************************************************************************
 InformaticsPluginDialog
                                 A QGIS plugin
 This is a test plug-in for the Geodetic Informatics II class.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-06-10
        git sha              : $Format:%H$
        copyright            : (C) 2023 by WSamek PPietrykowska
        email                : 01169913@pw.edu.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from math import *
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.utils import iface
from qgis.core import QgsWkbTypes
from PyQt5.QtGui import QFont
from PyQt5.QtCore import QRectF, Qt
from qgis.core import (
    QgsCoordinateReferenceSystem,
    QgsGeometry,
    QgsFeature,
    QgsField,
    QgsFields,
    QgsVectorLayer,
    QgsProject,
    QgsPoint,
)

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Informatics_plugin_dialog_base.ui'))


class InformaticsPluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(InformaticsPluginDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.pushbutton_count.clicked.connect(self.count_objects)
        self.pushbutton_showcoordinates.clicked.connect(self.enter_data_on_marked_object)
        self.pushbutton_hight.clicked.connect(self.calculate_height_difference)
        self.pushbutton_calculate.clicked.connect(self.area)
        self.pushbutton_clear.clicked.connect(self.clear_info)
        self.pushbutton_close.clicked.connect(self.closePlugin)
        
    def count_objects(self):
        selected_features = self.mMapLayerComboBox.currentLayer().selectedFeatures()
        number_of_selected_elements = len(selected_features)
        self.label_select.setText(str(number_of_selected_elements))

    def enter_data_on_marked_object(self):
        active_layer = iface.activeLayer()
        sel_features = active_layer.selectedFeatures()
        self.label_active.setText(active_layer.name())

        for feature in sel_features:
            geom = feature.geometry()
            geomSingleType = QgsWkbTypes.isSingleType(geom.wkbType())

            if geom.type() == QgsWkbTypes.PointGeometry:
                if geomSingleType:
                    x = geom.asPoint()
                    x_str = f'nr: {feature.attribute("nr")}, X: {x.x():.3f}, Y: {x.y():.3f}\r\n'
                    self.listObjects.append(x_str)
                else:
                    x = geom.asMultiPoint()
                    x_str = f'MultiPoint {feature.attribute("nr")}: {str(x)},3\r\n'
                    self.listObjects.append(x_str)
            elif geom.type() == QgsWkbTypes.LineGeometry:
                if geomSingleType:
                    x = geom.asPolyline()
                    x_str = f'Polyline {feature.attribute("nr")}: {str(x)},3\r\n'
                    self.listObjects.append(x_str)
                else:
                    x = geom.asMultiPolyline()
                    x_str = f'MultiPolyline {feature.attribute("nr")}: {str(x)},3\r\n'
                    self.listObjects.append(x_str)
            elif geom.type() == QgsWkbTypes.PolygonGeometry:
                if geomSingleType:
                    x = geom.asPolygon()
                    x_str = f'Polygon {feature.attribute("nr")}: {str(x)},3\r\n'
                    self.listObjects.append(x_str)
                else:
                    x = geom.asMultiPolygon()
                    x_str = f'MultiPolygon {feature.attribute("nr")}: {str(x)},3\r\n'
                    self.listObjects.append(x_str)
            else:
                print("Unknown or invalid geometry")


    def calculate_height_difference(self):
        selected_layer = self.mMapLayerComboBox.currentLayer()
        number_elements = len(selected_layer.selectedFeatures())
        if number_elements == 2:
            features = selected_layer.selectedFeatures()
            feature1 = features[0]
            feature2 = features[1]

            pnr1 = feature1["nr"]
            px1 = feature1["X"]
            py1 = feature1["Y"]
            pz1 = feature1["H"]

            pnr2 = feature2["nr"]
            px2 = feature2["X"]
            py2 = feature2["Y"]
            pz2 = feature2["H"]

            H = pz2 - pz1
            self.listoHigh.setText(f'The calculated elevation between point {pnr1} and point {pnr2} is {H:.3f} m')
        elif number_elements < 2:
            self.listoHigh.setText("Not enough points selected")
        else:
            self.listoHigh.setText("Too many points were selected")
            
    def area(self):
        selected_layer = self.mMapLayerComboBox.currentLayer()

        crs = selected_layer.crs()
        crs_authid = crs.authid() if crs else ''
        if 'EPSG:2180' in crs_authid:  # EPSG:2180 is for PL-1992
            self.label_crs.setText('PL-1992')
        elif 'EPSG:2176' in crs_authid:  # EPSG:2176 to EPSG:2179 are for PL-2000
            self.label_crs.setText('PL-2000 (5)')
        elif 'EPSG:2177' in crs_authid:
            self.label_crs.setText('PL-2000 (6)')
        elif 'EPSG:2178' in crs_authid:
            self.label_crs.setText('PL-2000 (7)')
        elif 'EPSG:2179' in crs_authid:
            self.label_crs.setText('PL-2000 (8)')

        selected_features = selected_layer.selectedFeatures()
        points = [feature.geometry().asPoint() for feature in selected_features]

        if len(points) < 3:
            self.label_area.setText("Not enough points selected")
            return

        # Sort points in clockwise order
        centroid = QgsPoint(sum(point.x() for point in points) / len(points), sum(point.y() for point in points) / len(points))
        points.sort(key=lambda point: -atan2(point.y() - centroid.y(), point.x() - centroid.x()))

        # Calculate area using Gauss's area formula
        area = 0.5 * abs(sum(points[i - 1].x() * points[i].y() - points[i].x() * points[i - 1].y() for i in range(len(points))))

        # Convert area to selected unit
        unit = self.comboBox_unit.currentText()
        if unit == 'm^2':
            area = area
        elif unit == 'Are':
            area *= 0.01
        elif unit == 'Hectare':
            area *= 0.0001

        self.label_area.setText(f'Area: {area:.3f} {unit}')

        if len(selected_features) > 0:
            # Create a new vector layer to hold the polygon feature
            if len(points) >= 3:
                new_layer = QgsVectorLayer("Polygon?crs=" + crs_authid, "Polygon Layer", "memory")
                provider = new_layer.dataProvider()
                new_layer.startEditing()

                # Create a polygon feature
                poly_feature = QgsFeature()
                polygon = QgsGeometry.fromPolygonXY([points])
                poly_feature.setGeometry(polygon)
                provider.addFeature(poly_feature)

                new_layer.commitChanges()
                QgsProject.instance().addMapLayer(new_layer)
            else:
                # Remove temporary polygon layer if it exists
                existing_layer = None
                for layer in QgsProject.instance().mapLayers().values():
                    if layer.name() == "Polygon Layer":
                        existing_layer = layer
                        break

                if existing_layer:
                    QgsProject.instance().removeMapLayer(existing_layer.id())

                  
    def clear_info(self):
        self.label_select.setText("")
        self.listObjects.clear()
        self.listoHigh.setText("")
        self.label_area.setText("")
        self.label_crs.setText("")
        self.label_active.setText("")

        # Remove temporary polygon layer if it exists
        existing_layer = None
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == "Polygon Layer":
                existing_layer = layer
                break

        if existing_layer:
            QgsProject.instance().removeMapLayer(existing_layer.id())
            
    def closePlugin(self):
        self.label_select.setText("")
        self.listObjects.clear()
        self.listoHigh.setText("")
        self.label_area.setText("")
        self.label_crs.setText("")
        self.label_active.setText("")

        existing_layer = None
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == "Polygon Layer":
                existing_layer = layer
                break

        if existing_layer:
            QgsProject.instance().removeMapLayer(existing_layer.id())

        self.close()